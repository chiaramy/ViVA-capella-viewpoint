# name                 : Validation Matrix
# script-type          : Python
# description          : Create a hierarchy for the all levels - codes changed
# popup                : enableFor(org.polarsys.capella.core.data.capellacore.CapellaElement)

'''
This script allows to extract all the elements in the model and create a Validation matrix that explore the main elements
 from the Physical Level to the Operational One.

It will create a folder result in the selected Capella project with the resulting xlsx file.
'''
# To run it:
#  - click on the script, select Run As -> EASE Script

# include needed for the Capella modeller API
include('workspace://Python4Capella/simplified_api/capella.py')
if False:
    from simplified_api.capella import *
    
# include needed for utilities
include('workspace://Python4Capella/utilities/CapellaPlatform.py')
if False:
    from utilities.CapellaPlatform import *
    
# include needed to read/write xlsx files
from openpyxl import *
from openpyxl.formatting.rule import ColorScaleRule,CellIsRule,FormulaRule
from openpyxl.styles import Alignment, NamedStyle, Font, colors, Color, PatternFill
from openpyxl.styles.differential import DifferentialStyle
from openpyxl.styles.borders import Border, Side
from openpyxl.utils import get_column_letter
from openpyxl.chart.data_source import Level
from openpyxl.worksheet.datavalidation import DataValidation


# ---- Configuration ----
aird_path = "xxx.aird"  # Change to your model path

# Open Capella model
model = CapellaModel()
model.open(aird_path)
se = model.get_system_engineering()
print('Starting export of model ' + se.get_name())

# Prepare Excel export path
project_name = aird_path[0:(aird_path.index("/", 1) + 1)]
project = CapellaPlatform.getProject(project_name)
folder = CapellaPlatform.getFolder(project, 'results')
xlsx_file_name = CapellaPlatform.getAbsolutePath(folder) + '/' + 'Validation Matrix Final.xlsx'

# Create a new workbook
workbook = Workbook()
worksheet = workbook.active
worksheet.title = 'Verification Matrix'

# =========================
# Functions
# =========================

def getSubElementsStore(elem, level=1, parent=None):
    """
    Recursively store all elements from Physical Architecture,
    including NodePC, BehaviorPC, and allocated Functions.
    Each element is stored with its name, type, level, and parent.
    """
    if isinstance(elem, NodePC):
        elem_type = "NodePC"
    elif isinstance(elem, BehaviorPC):
        elem_type = "BehaviorPC"
    else:
        elem_type = "Function"

    # Add element to list
    elements_data.append({
        'name': elem.get_name() or "<unnamed>",
        'type': elem_type,
        'level': level,
        'parent': parent.get_name() if parent else None,
        'obj': elem
    })

    # Recursive call for NodePC
    if isinstance(elem, NodePC):
        for subPC in elem.get_owned_physical_components():
            getSubElementsStore(subPC, level+1, elem)
        for bpc in elem.get_deployed_behavior_p_cs():
            getSubElementsStore(bpc, level+1, elem)

    # Recursive call for BehaviorPC
    if isinstance(elem, BehaviorPC):
        for subPC in elem.get_owned_physical_components():
            getSubElementsStore(subPC, level+1, elem)
        for func in elem.get_allocated_functions():
            getSubElementsStore(func, level+1, elem)


def collapse_multi_func_rows(rows):
    """
    For each row in rows_buffer:
      - if column 1 is NOT empty: new row, keep everything
      - otherwise: continuation row, keep only column 2
    """
    collapsed = []
    for row in rows:
        if row[0]:
            # row with new BehaviorPC
            collapsed.append(row)
        else:
            # additional function row: keep only col2
            collapsed.append(["", row[1], "", "", "", ""])
    return collapsed


def get_sub_logical_components(self) -> List[LogicalComponent]:
    """
    Returns: LogicalComponent[*]
    """
    return create_e_list(self.get_java_object().getSubLogicalComponents(), LogicalComponent)


def fill_logical_components(worksheet, elements_data, logical_map, start_row=3):
    """
    For each row in the worksheet (Physical Level),
    look for NodePCs in columns 3–6,
    retrieve the realized LogicalComponents,
    and write them into column 7 (Logical Component).
    """
    row_idx = start_row
    while any(worksheet.cell(row=row_idx, column=c).value for c in range(1, 7)):
        for col in range(3, 7):  # columns containing NodePCs
            node_name = worksheet.cell(row=row_idx, column=col).value
            if not node_name:
                continue

            # Find the NodePC element in elements_data
            node_elem = next(
                (e for e in elements_data if e['type'] == 'NodePC' and e['name'] == node_name),
                None
            )
            if not node_elem:
                continue

            # Retrieve realized Logical Components
            logicals = []
            try:
                for lc in node_elem['obj'].get_realized_logical_components():
                    logicals.append(lc.get_name())
                    lc_name = lc.get_name()
                    worksheet.cell(row=row_idx, column=7, value=lc_name).alignment = wrap_alignment
                    logical_map[lc_name] = lc  # salva il riferimento all’oggetto

            except Exception as e:
                print(f"Error on {node_name}: {e}")

            if logicals:
                worksheet.cell(row=row_idx, column=7, value=", ".join(logicals)).alignment = wrap_alignment

        row_idx += 1


def fill_logical_hierarchy_excel(worksheet, hierarchy, start_row=3):
    """
    For each row in the worksheet:
        - read column G (leaf node)
        - look up the leaf in the hierarchy
        - fill the following columns with parent1, parent2, ..., root
          leaving one empty column between each parent
          (first filled column = leaf + 2, i.e., column I if leaf is G)
    """
    col_leaf = 7  # column G = leaf
    max_row = worksheet.max_row

    for row_idx in range(start_row, max_row + 1):
        leaf_name = worksheet.cell(row=row_idx, column=col_leaf).value
        if not leaf_name:
            continue

        if leaf_name in hierarchy:
            parents = hierarchy[leaf_name]
            for offset, parent_name in enumerate(parents):
                # first parent starts at col_leaf + 2 (keeps the column after leaf empty)
                # then skip one column each time (offset * 2)
                target_col = col_leaf + 2 + (offset * 2)
                cell = worksheet.cell(row=row_idx, column=target_col)
                cell.value = parent_name
                cell.alignment = wrap_alignment


def build_logical_hierarchy(se):
    """
    Returns a dictionary:
        key: name of the LogicalComponent (leaf)
        value: list [parent1, parent2, ..., root] in ascending order
    """
    hierarchy = {}

    logical_archs = se.get_all_contents_by_type(LogicalArchitecture)
    if not logical_archs:
        return hierarchy

    la = logical_archs[0]

    def recurse_lc(lc, parent_chain=None):
        if parent_chain is None:
            parent_chain = []

        chain = parent_chain + [lc.get_name()]
        sub_lcs = get_sub_logical_components(lc)
        if not sub_lcs:
            # leaf node
            hierarchy[lc.get_name()] = chain[:-1][::-1]  # exclude the leaf, reverse: closest parent → root
        else:
            for sub in sub_lcs:
                recurse_lc(sub, chain)

    for root_lc in la.get_logical_component_pkg().get_owned_logical_components():
        recurse_lc(root_lc, [])

    return hierarchy
        
        

def fill_allocated_functions(worksheet, logical_map, start_row=3):
    """
    For each Logical Component in columns G, I, K:
      - retrieve the allocated functions from logical_map
      - write the first function in the next column (H, J, L)
      - if there are multiple functions, insert new rows below
        leaving the component column empty in those extra rows
    """

    # Define the pairs (component column, function column)
    pairs = [
        (7, 8),   # G → H
        (9, 10),  # I → J
        (11, 12)  # K → L
    ]

    # Start from the given row
    row_idx = start_row

    # Loop through all rows of the worksheet
    while row_idx <= worksheet.max_row:
        # For each pair of (component column, function column)
        for comp_col, func_col in pairs:
            # Read the component name from the current row
            comp_name = worksheet.cell(row=row_idx, column=comp_col).value
            if not comp_name:
                continue  # skip if the cell is empty

            # Retrieve the component object from the logical_map
            lc_obj = logical_map.get(comp_name)
            if not lc_obj:
                continue

            try:
                # Get the allocated functions (convert to Python list)
                functions = list(lc_obj.get_allocated_logical_functions())
            except Exception as e:
                print(f"Error on '{comp_name}': {e}")
                functions = []

            if functions:
                # Write the first function on the same row
                worksheet.cell(row=row_idx, column=func_col,
                               value=functions[0].get_name()).alignment = wrap_alignment

                # For each additional function...
                for f in functions[1:]:
                    # Insert a new row below
                    row_idx += 1
                    worksheet.insert_rows(row_idx)

                    # Leave the component column empty in the new row
                    worksheet.cell(row=row_idx, column=func_col,
                                   value=f.get_name()).alignment = wrap_alignment

        # Move to the next row
        row_idx += 1

def fill_system_component(worksheet, se, start_row=3):
    """
    Scrive il nome del System in colonna M (13)
    per ogni riga che ha un valore non vuoto in colonna K (Logical Component).
    """
    system_analysis = se.get_system_analysis()
    if not system_analysis:
        print("Nessuna System Analysis trovata.")
        return

    system = system_analysis.get_system()
    if not system:
        print("Nessun System trovato.")
        return

    system_name = system.get_name()

    max_row = worksheet.max_row
    for row_idx in range(start_row, max_row + 1):
        if worksheet.cell(row=row_idx, column=11).value:  # colonna K (Logical Component)
            cell = worksheet.cell(row=row_idx, column=13)  # colonna M (System Component)
            cell.value = system_name
            cell.alignment = wrap_alignment

def map_logical_to_system_functions(se):
    """
    Versione che usa get_container() per risalire al parent.
    Per ogni LogicalFunction:
      - recupera il parent se è una LogicalFunction
      - dal parent cerca le SystemFunctions realizzate
      - stampa tutto in console
    """
    try:
        all_lf = list(se.get_all_contents_by_type(LogicalFunction))
    except Exception as e:
        print(f"[ERROR] impossibile recuperare LogicalFunction: {e}")
        return

    if not all_lf:
        print("Nessuna LogicalFunction trovata.")
        return

    print("=== RELAZIONI LogicalFunction -> Parent -> Realized SystemFunctions ===")
    for lf in all_lf:
        lf_name = lf.get_name() or "<unnamed LF>"

        parent = None
        try:
            container = lf.get_container()
            if container and isinstance(container, LogicalFunction):
                parent = container
        except Exception:
            pass

        if not parent:
            print(f"- '{lf_name}': nessun parent (top-level o container non è una LogicalFunction).")
            continue

        parent_name = parent.get_name() or "<unnamed Parent>"

        # system functions realizzate dal parent
        sys_funcs = []
        try:
            sys_funcs = list(parent.get_realized_system_functions() or [])
        except Exception as e:
            print(f"- '{lf_name}' -> parent '{parent_name}': errore get_realized_system_functions(): {e}")

        sys_names = [sf.get_name() or "<unnamed SF>" for sf in sys_funcs]

        if sys_names:
            print(f"- '{lf_name}' -> parent '{parent_name}' -> SystemFunctions: {', '.join(sys_names)}")
        else:
            print(f"- '{lf_name}' -> parent '{parent_name}' -> nessuna SystemFunction realizzata.")

    print("=== Fine mappatura ===")


def fill_system_functions_from_logical(worksheet, se, start_row=3):
    """
    For each Logical Function (column H):
      - find its parent LogicalFunction
      - get the SystemFunctions realized by the parent
      - write the first SystemFunction name in column N of the same row

    After writing:
      - scan column N from top to bottom
      - if a cell has the same value as the nearest non-empty cell above,
        clear the current cell (to avoid consecutive duplicates)
    """
    try:
        all_lf = list(se.get_all_contents_by_type(LogicalFunction))
    except Exception as e:
        print(f"[ERROR] Unable to retrieve LogicalFunctions: {e}")
        return

    if not all_lf:
        print("No LogicalFunctions found in the model.")
        return

    # Map: Logical Function name -> LogicalFunction object
    lf_map = {lf.get_name(): lf for lf in all_lf if lf.get_name()}

    max_row = worksheet.max_row

    # --- FIRST PASS: populate column N ---
    for row_idx in range(start_row, max_row + 1):
        child_name = worksheet.cell(row=row_idx, column=8).value  # column H
        if not child_name:
            continue

        lf_obj = lf_map.get(child_name)
        if not lf_obj:
            continue  # skip if not found in the model

        # climb up to the parent LogicalFunction
        parent = None
        try:
            container = lf_obj.get_container()
            if container and isinstance(container, LogicalFunction):
                parent = container
        except Exception:
            pass

        if not parent:
            continue

        # get SystemFunctions realized by the parent
        sys_funcs = []
        try:
            sys_funcs = list(parent.get_realized_system_functions() or [])
        except Exception:
            pass

        if not sys_funcs:
            continue

        # write the first SystemFunction in column N
        sys_name = sys_funcs[0].get_name() if sys_funcs[0].get_name() else "<unnamed SF>"
        cell = worksheet.cell(row=row_idx, column=14)  # column N
        cell.value = sys_name
        cell.alignment = wrap_alignment

    # --- SECOND PASS: remove consecutive duplicates ---
    for row_idx in range(start_row, max_row + 1):
        current_val = worksheet.cell(row=row_idx, column=14).value
        if not current_val:
            continue

        # look upwards for the nearest non-empty cell
        for prev_idx in range(row_idx - 1, start_row - 1, -1):
            prev_val = worksheet.cell(row=prev_idx, column=14).value
            if not prev_val:
                continue  # skip empty rows
            # first non-empty cell found above
            if prev_val == current_val:
                # remove duplicate
                worksheet.cell(row=row_idx, column=14).value = None
            # stop checking once the first non-empty value is found
            break


def fill_operational_activities_from_system(worksheet, se, start_row=3):
    """
    Build SystemFunction hierarchy (parent -> children).
    For each child SystemFunction:
      - if the child name matches a value in column N (System Function),
      - find its parent SystemFunction,
      - retrieve OperationalActivities realized by the parent,
      - write the first OperationalActivity name into column O.
    """
    try:
        all_sf = list(se.get_all_contents_by_type(SystemFunction))
    except Exception as e:
        print(f"[ERROR] Unable to retrieve SystemFunctions: {e}")
        return

    if not all_sf:
        print("No SystemFunctions found in the model.")
        return

    # Map: SystemFunction name -> SystemFunction object
    sf_map = {sf.get_name(): sf for sf in all_sf if sf.get_name()}

    # --- Build hierarchy: child -> parent ---
    hierarchy = {}
    for sf in all_sf:
        for child in sf.get_contained_system_functions():
            if child.get_name():
                hierarchy[child.get_name()] = sf  # store parent

    max_row = worksheet.max_row

    # --- Match column N values with children ---
    for row_idx in range(start_row, max_row + 1):
        child_name = worksheet.cell(row=row_idx, column=14).value  # column N
        if not child_name:
            continue

        # find parent SystemFunction
        parent_sf = hierarchy.get(child_name)
        if not parent_sf:
            continue

        # get realized OperationalActivities from parent
        try:
            ops = list(parent_sf.get_realized_operational_activities() or [])
        except Exception:
            ops = []

        if not ops:
            continue

        # write first OperationalActivity in column O
        op_name = ops[0].get_name() if ops[0].get_name() else "<unnamed OA>"
        cell = worksheet.cell(row=row_idx, column=15)  # column O
        cell.value = op_name
        cell.alignment = wrap_alignment



            
def fill_entities_from_activity(worksheet, se, activity_col=15, start_row=3, entity_col=16):
    """
    For each OperationalActivity listed in column activity_col:
      - climb directly to its allocating OperationalEntity/Actor(s)
      - write entity names into column entity_col
    """

    max_row = worksheet.max_row
    for row_idx in range(start_row, max_row + 1):
        activity_name = worksheet.cell(row=row_idx, column=activity_col).value
        if not activity_name:
            continue

        # find the activity object by name
        activity_obj_list = [
            oa for oa in se.get_all_contents_by_type(OperationalActivity)
            if oa.get_name() == activity_name
        ]
        if not activity_obj_list:
            continue

        activity_obj = activity_obj_list[0]

        try:
            entities = activity_obj.get_allocating_entity()
        except Exception:
            entities = []

        # normalize: ensure entities is a list
        if entities is None:
            entities = []
        elif not isinstance(entities, list):
            entities = [entities]

        entity_names = []
        for ent in entities:
            try:
                entity_names.append(ent.get_name())
            except Exception:
                continue

        if entity_names:
            worksheet.cell(row=row_idx, column=entity_col, value=", ".join(entity_names))



# --- Build mappings using involvedAbstractFunctions (robusto e tollerante) ---
def build_activity_capability_mappings_from_capella(se):
    """
    Scansiona tutte le OperationalCapability del modello e legge la reference
    'involvedAbstractFunctions' (che contiene AbstractFunction). Filtra le
    AbstractFunction che sono OperationalActivity e costruisce due dizionari:
      - activity_to_caps: { activity_name: [cap_name, ...] }
      - cap_to_acts: { cap_name: [activity_name, ...] }
    Ritorna (activity_to_caps, cap_to_acts)
    """
    # recupera liste tramite wrapper (dovrebbe funzionare nel tuo ambiente)
    try:
        caps = list(se.get_all_contents_by_type(OperationalCapability))
    except Exception:
        caps = []

    try:
        all_activities = list(se.get_all_contents_by_type(OperationalActivity))
    except Exception:
        all_activities = []

    activity_to_caps = {}
    cap_to_acts = {}

    for cap in caps:
        # nome capability (gestione fallback)
        try:
            cap_name = cap.get_name() or cap.getName()
        except Exception:
            try:
                cap_name = cap.getName()
            except Exception:
                cap_name = "<unnamed OC>"

        # tentativo 1: ottenere java object e cercare la feature direttamente
        val = None
        oc_java = None
        try:
            oc_java = cap.get_java_object()
        except Exception:
            oc_java = None

        if oc_java is not None:
            # prova getEStructuralFeature("involvedAbstractFunctions")
            try:
                feat = oc_java.eClass().getEStructuralFeature("involvedAbstractFunctions")
                if feat:
                    val = oc_java.eGet(feat)
            except Exception:
                val = None

            # fallback: iterare tutte le references e trovare quella col nome giusto
            if val is None:
                try:
                    refs = oc_java.eClass().getEAllReferences()
                    for r in refs:
                        try:
                            if r.getName() == "involvedAbstractFunctions":
                                val = oc_java.eGet(r)
                                break
                        except Exception:
                            continue
                except Exception:
                    pass

        # fallback 2: provare wrapper Python/Java method names se val ancora None
        if val is None:
            try:
                # metodo wrapper snake_case?
                val = cap.get_involved_abstract_functions()
            except Exception:
                try:
                    # camelCase Java style wrapper?
                    val = cap.getInvolvedAbstractFunctions()
                except Exception:
                    val = None

        # normalizza la collezione in lista Python
        items = []
        if val:
            try:
                for it in val:
                    items.append(it)
            except Exception:
                # singolo oggetto
                items = [val]

        # filtra solo OperationalActivity e raccogli nomi
        act_names = []
        for item in items:
            try:
                # tipo Ecore
                etype = None
                try:
                    etype = item.eClass().getName()
                except Exception:
                    pass

                if etype != "OperationalActivity":
                    # potrebbe essere sottotipo o wrapper; controlla anche nome classe completa
                    try:
                        if "OperationalActivity" not in str(item.eClass().getName()):
                            continue
                    except Exception:
                        continue

                # prendi nome (gestione fallback)
                a_name = None
                try:
                    a_name = item.get_name()
                except Exception:
                    try:
                        a_name = item.getName()
                    except Exception:
                        a_name = "<unnamed OA>"

                act_names.append(a_name)
                activity_to_caps.setdefault(a_name, []).append(cap_name)
            except Exception:
                # ignora singoli elementi problematici
                continue

        cap_to_acts[cap_name] = act_names

    # Assicuriamoci che tutte le attività note appaiano nella mappa (anche se non collegate)
    for oa in all_activities:
        try:
            name = oa.get_name() or oa.getName()
        except Exception:
            try:
                name = oa.getName()
            except Exception:
                name = "<unnamed OA>"
        activity_to_caps.setdefault(name, [])

    return activity_to_caps, cap_to_acts

def fill_operational_capabilities(worksheet, se):
    """
    Automatically fills OperationalCapabilities for each OperationalActivity in the worksheet.
    - Detects OperationalActivity names from column O (15)
    - Writes connected OperationalCapabilities in column Q (17)
    - If multiple capabilities, writes each in a separate row under the same OA
    - Uses robust mapping via involvedAbstractFunctions
    """
    # Build mappings: activity_name -> [cap_name, ...]
    activity_to_caps, _ = build_activity_capability_mappings_from_capella(se)

    max_row = worksheet.max_row
    row_offset = 0  # To handle multiple OC per OA

    for row_idx in range(3, max_row + 1):
        oa_cell = worksheet.cell(row=row_idx + row_offset, column=15)  # Column O
        oa_name = oa_cell.value
        if not oa_name:
            continue

        caps = activity_to_caps.get(oa_name, [])
        if not caps:
            # Write placeholder if no OC
            worksheet.cell(row=row_idx + row_offset, column=17, value="")
        else:
            # Write each OC in separate row under OA
            for i, cap in enumerate(caps):
                target_row = row_idx + row_offset + i
                worksheet.cell(row=target_row, column=17, value=cap)
            # Increase offset to skip rows we just filled
            row_offset += len(caps) - 1

def fill_post_conditions_excel(worksheet, se, capability_col=17, postcond_col=18, start_row=3):
    """
    Per ogni OperationalCapability elencata in 'capability_col':
    - legge la post-condition (stringa diretta o OpaqueExpression)
    - scrive il testo nella colonna 'postcond_col'
    - gestisce casi vuoti o assenti
    """
    try:
        all_caps = list(se.get_all_contents_by_type(OperationalCapability))
    except Exception as e:
        print(f"[ERROR] impossibile recuperare OperationalCapability: {e}")
        return

    if not all_caps:
        print("Nessuna OperationalCapability trovata.")
        return

    # Costruisce un mapping: nome capability -> oggetto
    cap_map = {oc.get_name(): oc for oc in all_caps if oc.get_name()}

    max_row = worksheet.max_row
    for row_idx in range(start_row, max_row + 1):
        cap_name = worksheet.cell(row=row_idx, column=capability_col).value
        if not cap_name:
            continue

        post_cond_text = "<no post-condition>"
        oc = cap_map.get(cap_name)
        if oc:
            try:
                cond = oc.get_post_condition()
                if cond:
                    spec = getattr(cond, "get_specification", lambda: None)()
                    if spec:
                        if isinstance(spec, str):
                            post_cond_text = spec
                        else:
                            # prova OpaqueExpression con get_values
                            values = getattr(spec, "get_values", lambda: [])()
                            if values:
                                post_cond_text = " ".join(values)
                            else:
                                post_cond_text = "<empty post-condition>"
                    else:
                        post_cond_text = "<empty post-condition>"
            except Exception:
                post_cond_text = "<error reading post-condition>"

        cell = worksheet.cell(row=row_idx, column=postcond_col)
        cell.value = post_cond_text
        cell.alignment = wrap_alignment  # mantiene lo stesso stile wrap text






# =========================
# Excel Formatting
# =========================
color_physical = "F4B084"    # Light orange for Physical Level
color_logical = "9BC2E6"     # Light blue for Logical Level
color_system = "FFD966"      # Yellow for System level
color_operational = "C6E0B4" # Green for Operational Level

color_subheader = "FFF2CC"  # Light beige for subheader

header_font = Font(bold=False, name="Calibri")
center_alignment = Alignment(horizontal="center", vertical="center")

worksheet.auto_filter.ref = "A2:S2"
worksheet.freeze_panes = "A3"

# Create a named style for wrap text if it doesn't exist
if "wrap_style" not in workbook.named_styles:
    wrap_style = NamedStyle(name="wrap_style")
    wrap_style.alignment = Alignment(wrap_text=True, vertical="top")
    workbook.add_named_style(wrap_style)
else:
    wrap_style = workbook.named_styles["wrap_style"]

# =========================
# Prima riga - macro sezioni
# =========================
# Physical Level 
worksheet.merge_cells(start_row=1, start_column=1, end_row=1, end_column=6)
cell = worksheet.cell(row=1, column=1, value="Physical Level")
cell.fill = PatternFill(start_color=color_physical, end_color=color_physical, fill_type="solid")
cell.font = header_font
cell.alignment = center_alignment

# Logical Level 
worksheet.merge_cells(start_row=1, start_column=7, end_row=1, end_column=12)
cell = worksheet.cell(row=1, column=7, value="Logical level")
cell.fill = PatternFill(start_color=color_logical, end_color=color_logical, fill_type="solid")
cell.font = header_font
cell.alignment = center_alignment

# System Level 
worksheet.merge_cells(start_row=1, start_column=13, end_row=1, end_column=14)
cell = worksheet.cell(row=1, column=13, value="System level")
cell.fill = PatternFill(start_color=color_system, end_color=color_system, fill_type="solid")
cell.font = header_font
cell.alignment = center_alignment

# Operational Level 
worksheet.merge_cells(start_row=1, start_column=15, end_row=1, end_column=19)
cell = worksheet.cell(row=1, column=15, value="Operational Level")
cell.fill = PatternFill(start_color=color_operational, end_color=color_operational, fill_type="solid")
cell.font = header_font
cell.alignment = center_alignment

# =========================
# Second row - detailed headers
# =========================
headers = [
    # Physical level
    "Behaviour Component", "Function", "Physical Node", "Physical Node", "Physical Node", "Function",
    # Logical level
    "Logical Component", "Function", "Logical Component", "Function", "Logical Component", "Function",
    # System level
    "System Component", "Function",
    # Operational level
    "Operational activities", "Operational Entity", "Operational Capabilities", "Success Criteria", "Validation Check"
]

for idx, h in enumerate(headers, start=1):
    c = worksheet.cell(row=2, column=idx, value=h)
    c.fill = PatternFill(start_color=color_subheader, end_color=color_subheader, fill_type="solid")
    c.font = header_font
    c.alignment = center_alignment
    worksheet.column_dimensions[get_column_letter(idx)].width = 22






# =========================
# Store elements recursively
# =========================
elements_data = []

# Loop over root NodePCs in the Physical System
for npc in se.get_physical_architecture().get_physical_system().get_owned_physical_components():
    if isinstance(npc, NodePC):
        getSubElementsStore(npc, level=1, parent=None)


# ----------------------------
# Build set of all parent names (used to skip NodePC duplicates)
# ----------------------------
parent_set = set(item['parent'] for item in elements_data if item.get('parent'))

# ----------------------------
# Build all rows first (store temporarily before writing)
# ----------------------------
rows_buffer = []
wrap_alignment = wrap_style.alignment

# sort physical elements by descending depth
physical = [e for e in elements_data if e['type'] in ('NodePC','BehaviorPC')]
for e in sorted(physical, key=lambda x: -x['level']):
    # BehaviorPC with one or more allocated Functions
    if e['type'] == 'BehaviorPC':
        funcs = [f for f in elements_data
                 if f['type'] == 'Function' and f['parent'] == e['name']]
        if funcs:
            first = True
            for f in funcs:
                row = [""] * 6
                # always write function name
                row[1] = f['name']
                if first:
                    # first function: write component + hierarchy
                    row[0] = e['name']
                    parent_col = 2
                    parent_name = e.get('parent')
                    while parent_name and parent_col < 6:
                        row[parent_col] = parent_name
                        parent_item = next(
                            (x for x in elements_data if x['name'] == parent_name),
                            None
                        )
                        parent_name = parent_item['parent'] if parent_item else None
                        parent_col += 1
                    first = False
                rows_buffer.append(row)
            continue  # skip the NodePC/default logic

    # NodePC or BehaviorPC with no funcs → single row
    row = [""] * 6
    row[0] = e['name']
    # fill parent chain col3–6
    parent_col = 2
    parent_name = e.get('parent')
    while parent_name and parent_col < 6:
        row[parent_col] = parent_name
        parent_item = next(
            (x for x in elements_data if x['name'] == parent_name),
            None
        )
        parent_name = parent_item['parent'] if parent_item else None
        parent_col += 1
    rows_buffer.append(row)


# ----------------------------------------------------------------
# After filling rows_buffer, collapse multi-function rows
# ----------------------------------------------------------------

rows_buffer = collapse_multi_func_rows(rows_buffer)


# ----------------------------
# Consistency check: remove duplicate parents
# ----------------------------
# 1. Build the set of all parent names (ignore empty strings)
all_parents = {
    parent
    for row in rows_buffer
    for parent in row[2:6]
    if parent
}

# 2. Filter: 
#    - keep rows where col1 is blank (continuation rows), OR
#    - keep rows where col1 is not in all_parents (first occurrence only)
filtered_rows = [
    row
    for row in rows_buffer
    if (not row[0]) or (row[0] not in all_parents)
]


# ----------------------------
# Write rows to Excel
# ----------------------------
row_idx = 3
for r in filtered_rows:
    for col_idx, val in enumerate(r, start=1):
        if val:
            worksheet.cell(row=row_idx, column=col_idx, value=val).alignment = wrap_alignment
    row_idx += 1


# ----------------------------
# Simple duplicate removal based on column 1
# ----------------------------
row_idx = 3  # starting row (after headers)
seen = set()

while row_idx <= worksheet.max_row:
    cell_val = worksheet.cell(row=row_idx, column=1).value
    if cell_val:
        if cell_val in seen:
            # duplicate found, delete this row
            worksheet.delete_rows(row_idx)
            # also delete subsequent rows if column 1 is empty
            while row_idx <= worksheet.max_row and not worksheet.cell(row=row_idx, column=1).value:
                worksheet.delete_rows(row_idx)
            # do not increment row_idx, since rows shifted up
            continue
        else:
            seen.add(cell_val)
    row_idx += 1

# ----------------------------
# Logical Level
# ----------------------------
logical_map = {}  # dizionario nome -> oggetto LogicalComponent


fill_logical_components(worksheet, elements_data, logical_map, start_row=3)

fill_logical_hierarchy_excel(worksheet, build_logical_hierarchy(se), start_row=3)

fill_allocated_functions(worksheet, logical_map, start_row=3)

# ----------------------------
# System Level
# ----------------------------

fill_system_component(worksheet, se, start_row=3)
fill_system_functions_from_logical(worksheet, se, start_row=3)

#map_logical_to_system_functions(se)


# ----------------------------
# Operational Level
# ----------------------------

fill_operational_activities_from_system(worksheet, se, start_row=3)

fill_entities_from_activity(worksheet, se, activity_col=15, start_row=3, entity_col=16)

fill_operational_capabilities(worksheet, se)

fill_post_conditions_excel(worksheet, se, capability_col=17, postcond_col=18, start_row=3)

# =========================
# Save & Refresh
# =========================
workbook.save(xlsx_file_name)
print(f"Excel file saved at: {xlsx_file_name}")
CapellaPlatform.refresh(folder)
